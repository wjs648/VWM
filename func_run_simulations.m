function [S,P,R1,R2,R3,R4] = func_run_simulations(c)
%func_run_simulations returns arrays containing the stimulus locations,
%probe stimuli location, and location responses generated by each model.
%Parameters: c, config structure
%   Detailed explanation goes here

S=cell(1, length(c.SS)); % Return all stimulus arrays
P=nan(c.n_trl, length(c.SS)); % Locations of probe stimuli
R1=nan(c.n_trl, length(c.SS)); % Locations of responses, Luck model
R2=nan(c.n_trl, length(c.SS)); % Locations of responses guessing excluding locations of items in memory
R3=nan(c.n_trl, length(c.SS)); % Locations of responses, guessing *only* the locations of items in memory (pure swap model)
R4=nan(c.n_trl, length(c.SS)); % Locations of responses, guessing the location of the closest item in memory if its within X degrees (chunking model)
for i=1:length(c.SS)
    ss=c.SS(i); % Set size
    L=nan(c.n_trl, ss); % Log all spatial locations of stimulus array
    C=nan(c.n_trl, ss); % Log all colours of stimulus array
    for t=1:c.n_trl
        
        % Simulate inter-participant variaiblity in k ?
        %             c.k=randsample([2,3,4],1); %
        
        % Stimulus array, randomly chosen without replacement
        clr=datasample(c.Clr, ss, 'Replace', false);
        [loc, Loc_spc]=func_get_locations_periodic(c, ss);
        
        % Keep track of stimulus array locations and colours
        L(t,1:ss)=loc;
        C(t,1:ss)=clr;
        
        p_idx=randperm(ss,1); % Index of probed item
        P(t,i)=loc(p_idx); % Location of the probed item
        if ss<=c.k % If set size is less than capacity ...
            %                 M_idx=1:ss; % ... all items are in memory (UNNECESSARY)
            R1(t,i)=P(t,i)+0; % Response is probe + noise
            R2(t,i)=P(t,i)+0; % Response is probe + noise
            R3(t,i)=P(t,i)+0; % Response is probe + noise
            R4(t,i)=P(t,i)+0; % Response is probe + noise
        else
            M_idx=randperm(ss,c.k); % Indeces of remembered items
            if ismember(p_idx,M_idx) % No need to guess
                R1(t,i)=P(t,i)+0;
                R2(t,i)=P(t,i)+0;
                R3(t,i)=P(t,i)+0;
                R4(t,i)=P(t,i)+0;
            else % Probed item is not in memory, so we have to guess
                Loc_g=setdiff(c.Loc,Loc_spc); % Locations from which to guess
                R1(t,i)=datasample(c.Loc,1); % Draw from anywhere
                R2(t,i)=datasample(Loc_g,1); % Draw locations not in memory
                R3(t,i)=datasample(loc,1); % TRT DRAWING FROM ALL SURROUNDING LOCATIONS (within min distance)
                
                % Model 4, chunking
                Ch=func_chunk_feature_values_periodic(c, loc);
                r4=datasample(c.Loc,1); % Draw from anywhere
                for j=1:length(Ch)
                    ch=Ch{j};
                    if length(ch)==1 % Item wasn't chunked with other items
                        continue;
                    end
                    if ismember(p_idx,ch) % Probe was chunked with at least one other item
                        ch(ch==p_idx)=[];
                        r4=datasample(loc(ch),1)+0;
                        break;
                    end
                end
                R4(t,i)=r4;
            end
        end
    end
    S{i}=[L,C];
end

gamma=1; % Scale the scaling of the SD parameter of normrnd (<=k only)
z=c.SS;
z(z>c.k)=c.k;
Z=gamma * repmat(z, c.n_trl,1);
R1=R1 + Z.* normrnd(0,c.loc_min_dst/2, size(R1,1), size(R1,2));
R2=R2 + Z.* normrnd(0,c.loc_min_dst/2, size(R2,1), size(R2,2));
R3=R3 + Z.* normrnd(0,c.loc_min_dst/2, size(R3,1), size(R3,2));
R4=R4 + Z.* normrnd(0,c.loc_min_dst/2, size(R4,1), size(R4,2));
end

